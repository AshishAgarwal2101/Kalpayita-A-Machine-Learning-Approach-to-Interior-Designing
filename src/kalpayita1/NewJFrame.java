/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package kalpayita1;

import edu.stanford.nlp.coref.CorefCoreAnnotations.CorefChainAnnotation;
import edu.stanford.nlp.coref.data.CorefChain;
import edu.stanford.nlp.coref.data.CorefChain.CorefMention;
import edu.stanford.nlp.ling.CoreAnnotations.LemmaAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.NamedEntityTagAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.PartOfSpeechAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.SentencesAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.TextAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.TokensAnnotation;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.pipeline.*;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation;
import edu.stanford.nlp.semgraph.SemanticGraphFactory;
import edu.stanford.nlp.semgraph.semgrex.SemgrexMatcher;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations.TreeAnnotation;
import edu.stanford.nlp.util.CoreMap;
import java.io.FileReader;
import java.text.BreakIterator;
import java.util.*;
import javax.swing.JOptionPane;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

/**
 *
 * @author Ashish
 */
public class NewJFrame extends javax.swing.JFrame {
    ArrayList<Description> descriptions = new ArrayList<>();
    ArrayList<Scene> scenes = new ArrayList<>();
    ArrayList<String> nouns = new ArrayList<>();
    ArrayList<String> objectCategories = new ArrayList<>();
    ArrayList<String> adjectives = new ArrayList<>();
    ArrayList<String> otherNouns = new ArrayList<>();
    Properties props;
    StanfordCoreNLP pipeline;
    Annotation document;
    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
        props = new Properties();
        props.put("annotators", "tokenize, ssplit, pos, lemma, ner, parse, dcoref");
        pipeline = new StanfordCoreNLP(props);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(162, 162, 162)
                .addComponent(jButton1)
                .addContainerGap(165, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(107, 107, 107)
                .addComponent(jButton1)
                .addContainerGap(170, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        try{
            initializeScenesAndDescriptions();
            doWork("There is a chair. The chair is red in color.");
            /*JOptionPane.showMessageDialog(null, descriptions.get(0).description+" "+descriptions.get(0).descriptionId+" "+descriptions.get(0).sceneId, "InfoBox: ", JOptionPane.INFORMATION_MESSAGE);
            JOptionPane.showMessageDialog(null, scenes.get(0).sceneId+" "+scenes.get(0).description, "InfoBox: ", JOptionPane.INFORMATION_MESSAGE);*/
            /*CoreDocument document = new CoreDocument(descriptions.get(0).description);
            pipeline.annotate(document);
            
            document.tokens();*/
            
            /*// list of ner tags for the second sentence
            CoreSentence sentence = document.sentences().get(0);
            List<String> posTags = sentence.nerTags();
            System.out.println("Example: ner tags");
            //JOptionPane.showMessageDialog(null, description+"\n"+sceneId, "InfoBox: ", JOptionPane.INFORMATION_MESSAGE);
            System.out.println(posTags);
            System.out.println();
            
            // constituency parse for the second sentence
            Tree constituencyParse = sentence.constituencyParse();
            System.out.println("Example: constituency parse");
            System.out.println(constituencyParse);
            System.out.println();*/
            
            // dependency parse for the second sentence
            /*SemanticGraph dependencyParse = sentence.dependencyParse();
            System.out.println("Example: dependency parse");
            System.out.println(dependencyParse);
            System.out.println();*/
        }catch (Exception e) {
            e.printStackTrace();
        } 
    }//GEN-LAST:event_jButton1ActionPerformed
    private void doWork(String text){
        // create an empty Annotation just with the given text
        try{
            document = new Annotation(text);
            pipeline.annotate(document);

            text = coreferencePart(text);
            // create an empty Annotation just with the given text
            document = new Annotation(text);
            pipeline.annotate(document);
        
            List<CoreMap> sentences = document.get(SentencesAnnotation.class);
            initializeNouns(sentences);
            
        /*for(CoreMap sentence: sentences) {
            // this is the parse tree of the current sentence
            Tree tree = sentence.get(TreeAnnotation.class);
            System.out.println("tree: "+tree);
            
            String[] patterns = {"{}=dobj >cop {} >nsubj {}=nsubj >prep ({}=prep >pobj {}=pobj)", "{}=nsubj >advmod ({}=advmod >prep ({}=prep >pobj {}=pobj))", "{tag:VBN}=verb >nsubjpass {}=nsubj >prep ({}=prep >pobj {}=pobj)", "{}=dobj >cop {} >nsubj {}=nsubj"};
            SemanticGraph graph = SemanticGraphFactory.generateUncollapsedDependencies(tree);
            for(int i=0; i<patterns.length; i++){
                SemgrexPattern semgrex = SemgrexPattern.compile(patterns[i]);
                System.out.println("Pattern: "+semgrex.pattern()+"  ....");
                SemgrexMatcher matcher = semgrex.matcher(graph);
                while (matcher.find()) {
                    if(i == 0){
                        System.out.println(matcher.getNode("dobj") + "(" + matcher.getNode("nsubj") + "," + matcher.getNode("pobj") + ")");
                    }
                    else if(i == 1){
                        System.out.println(matcher.getNode("advmod")+ "(" + matcher.getNode("nsubj") + "," + matcher.getNode("pobj") + ")");
                    }
                    else if(i == 2){
                        System.out.println(matcher.getNode("verb") + "(" + matcher.getNode("nsubj") + "," + matcher.getNode("pobj") + ")");
                    }
                    else{
                        System.out.println("(" + matcher.getNode("nsubj") + "," + matcher.getNode("dobj") + ")");
                    }
                }
            }

            // this is the Stanford dependency graph of the current sentence
            //SemanticGraph dependencies = sentence.get(CollapsedCCProcessedDependenciesAnnotation.class);
        }*/
            System.out.println("nouns: "+nouns);
            System.out.println("adjectives: "+adjectives);
            System.out.println("other nouns: "+otherNouns);
            System.out.println("objectCategories: "+objectCategories);
        /*System.out.println("Nouns....");
        for(String s:nouns){
            System.out.print(s+"  ");
        }
        System.out.println();*/
        }catch(Exception e){
            e.printStackTrace();
        }
        
    }
    public void initializeScenesAndDescriptions(){
        JSONParser parser;
        parser = new JSONParser();
        try{
        JSONObject o = (JSONObject) parser.parse(new FileReader("src\\resources\\json\\descriptions.json"));
            Set<String> keys = (Set<String>) o.keySet();
            for(String key:keys){
                String descriptionId = key;
                JSONObject o1 = (JSONObject) o.get(key);
                JSONObject o2 = (JSONObject) o1.get("data");
                String description = (String)o2.get("description");
                JSONObject o3 = (JSONObject) o2.get("entry");
                String sceneIdForDescription = (String) o3.get("id");
                Description desc = new Description(descriptionId, description, sceneIdForDescription);
                descriptions.add(desc);
            }
            
            o = (JSONObject) parser.parse(new FileReader("src\\resources\\json\\scenes.json"));
            keys = (Set<String>) o.keySet();
            for(String key:keys){
                String sceneId = key;
                JSONObject o1 = (JSONObject) o.get(key);
                JSONObject o2 = (JSONObject) o1.get("data");
                JSONObject o3 = (JSONObject) o2.get("entry");
                String descriptionIdForScene = (String) o3.get("description");
                Scene scene = new Scene(sceneId, descriptionIdForScene);
                scenes.add(scene);
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public String coreferencePart(String text){
        //Adding words to replace in sentences
        Map<Integer, CorefChain> graph1 = document.get(CorefChainAnnotation.class);
        System.out.println(graph1);
        HashMap<Integer, ArrayList<String>> wordsHashMap = new HashMap<Integer, ArrayList<String>>();
        HashMap<Integer, ArrayList<String>> wordsReplaceHashMap = new HashMap<Integer, ArrayList<String>>();
        for(int i:graph1.keySet()){
            CorefMention representativeMention = graph1.get(i).getRepresentativeMention();
            String word = representativeMention.mentionSpan;
            List<CorefMention> corefMentions = graph1.get(i).getMentionsInTextualOrder();
            for(int j=0; j<corefMentions.size(); j++){
                int sentenceNumber = corefMentions.get(j).sentNum;
                String wordToReplace = corefMentions.get(j).mentionSpan;
                ArrayList<String> words1;
                ArrayList<String> replaceWords1;
                if(wordsHashMap.containsKey(sentenceNumber)){
                    words1 = wordsHashMap.get(sentenceNumber);
                    replaceWords1 = wordsReplaceHashMap.get(sentenceNumber);
                    wordsHashMap.remove(sentenceNumber);
                    wordsReplaceHashMap.remove(sentenceNumber);
                }
                else{
                    words1 = new ArrayList<>();
                    replaceWords1 = new ArrayList<>();
                }
                words1.add(word);
                replaceWords1.add(wordToReplace);
                wordsHashMap.put(sentenceNumber, words1);
                wordsReplaceHashMap.put(sentenceNumber, replaceWords1);
            }
        }
        //replacing with desired words
        BreakIterator iterator = BreakIterator.getSentenceInstance(Locale.US);
        String source = text;
        iterator.setText(source);
        int start = iterator.first();
        int senNumber = 1;
        String finalText = "";
        for (int end = iterator.next(); end != BreakIterator.DONE; start = end, end = iterator.next()) {
            String sentence = source.substring(start,end);
            ArrayList<String> wordsArrayList = wordsHashMap.get(senNumber);
            ArrayList<String> wordsReplaceArrayList = wordsReplaceHashMap.get(senNumber);
            for(int i=0; i<wordsArrayList.size(); i++){
                String word = wordsArrayList.get(i);
                String replaceWord = wordsReplaceArrayList.get(i);
                int index = sentence.indexOf(replaceWord);
                while (index >= 0) {
                    if(index == 0 || sentence.charAt(index-1)==' '){
                        sentence = sentence.substring(0, index) + word + sentence.substring(index+replaceWord.length());
                        //sentence = sentence.replace(replaceWord, word);
                    }
                    index = sentence.indexOf(replaceWord, index + 1);
                }
            }
            finalText += sentence;
            senNumber++;
        }
        return finalText;
        
    }
    public void initializeNouns(List<CoreMap> sentences){
        /*POS Labels:
        
        CC Coordinating conjunction
        CD Cardinal number
        DT Determiner
        EX Existential there
        FW Foreign word
        IN Preposition or subordinating conjunction
        JJ Adjective
        JJR Adjective, comparative
        JJS Adjective, superlative
        LS List item marker
        MD Modal
        NN Noun, singular or mass
        NNS Noun, plural
        NNP Proper noun, singular
        NNPS Proper noun, plural
        PDT Predeterminer
        POS Possessive ending
        PRP Personal pronoun
        PRP$ Possessive pronoun
        RB Adverb
        RBR Adverb, comparative
        RBS Adverb, superlative
        RP Particle
        SYM Symbol
        TO to
        UH Interjection
        VB Verb, base form
        VBD Verb, past tense
        VBG Verb, gerund or present participle
        VBN Verb, past participle
        VBP Verb, non­3rd person singular present
        VBZ Verb, 3rd person singular present
        WDT Wh­determiner
        WP Wh­pronoun
        WP$ Possessive wh­pronoun
        WRB Wh­adverb*/
        
        for(CoreMap sentence: sentences) {
            // traversing the words in the current sentence
            // a CoreLabel is a CoreMap with additional token-specific methods
            for (CoreLabel token: sentence.get(TokensAnnotation.class)) {
                // this is the text of the token
                String word = token.get(TextAnnotation.class);
                // this is the POS tag of the token
                String pos = token.get(PartOfSpeechAnnotation.class);
                // this is the NER label of the token
                String ne = token.get(NamedEntityTagAnnotation.class); 
                // perform lemmatization
                String lem = token.get(LemmaAnnotation.class);
                if(pos.equals("NN")){
                    if(!nouns.contains(lem)){
                        nouns.add(lem);
                        if(!physicalObjFinding(lem)){
                            otherNouns.add(lem);
                        }
                        else{
                            objectCategories.add(lem);
                        }
                    }
                }
                else if(pos.equals("JJ")){
                    if(!adjectives.contains(lem)){
                        adjectives.add(lem);
                    }
                }
                
                /*System.out.print("word: "+word+"...");
                System.out.print("pos: "+pos+"....");
                System.out.print("ne: "+ne+"....");
                System.out.print("lemma: "+lem+"...");
                System.out.println();*/
            }
        }
    }
    public boolean physicalObjFinding(String t)
    {
        WordNet net = new WordNet("src\\resources\\WordNet\\properties.xml");
        return net.isPhysicalObject(t) && !net.isLocation(t);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    // End of variables declaration//GEN-END:variables
}
